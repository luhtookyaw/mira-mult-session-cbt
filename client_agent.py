# client_agent.py
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import json

from llm import call_llm
from event_narratizer import narrativize_period


@dataclass
class ClientAgent:
    """
    CBT-style simulated client.

    SYSTEM prompt:
      - persona_text: full persona block generated by persona_generator.py
      - long_term_summary: running summary of past work / history

    USER prompt (per turn):
      - Current period diary paragraph (Rolling Window = 1)
      - JSON facts for this period (ground truth)
      - Recent conversation history (last few turns)
      - Therapist's latest utterance (the stimulus)

    Narrativization:
      - Diary paragraphs are NOT pre-generated.
      - For each session k:
          1) Assume the relevant storyline period has been updated
             (e.g., between_sessions_1_2 after Session 1).
          2) Narrativize that period ON DEMAND using narrativize_period(...)
          3) Cache the result in diary_store.
    """

    # Full persona block, e.g. the 1–5 bullet structure you showed
    persona_text: str

    # Section B: accumulated therapy history summary
    long_term_summary: str = ""

    # Label used only for conversation history formatting ("Client" by default)
    client_label: str = "Client"

    model: str = "gpt-4o-mini"

    # Internal cache for diary paragraphs keyed by period name
    diary_store: Dict[str, str] = field(default_factory=dict)

    # --------------------------
    # SYSTEM prompt construction
    # --------------------------
    def _build_system_prompt(self) -> str:
        summary_block = (
            self.long_term_summary.strip()
            if self.long_term_summary.strip()
            else "No important past conversations are remembered yet."
        )

        system_prompt = f"""### CLIENT PERSONA
{self.persona_text}

### THERAPY HISTORY (Long-Term Memory)
{summary_block}

### GLOBAL INSTRUCTIONS
- You are the person described in the CLIENT PERSONA above.
- Always speak in the first person ("I").
- Stay consistent with the identity, core struggle, patterns, and interaction style described above.
- Express your thoughts, emotions, doubts, and avoidance patterns naturally.
- Use 2–5 sentences per reply unless the situation clearly calls for more.
- Do NOT be perfectly rational; allow anxiety, guilt, avoidance, or ambivalence to appear.
- Do NOT mention therapy, prompts, JSON, or that you are an AI or a simulation.
- Never break character.
"""     
        
        print(system_prompt)
        
        return system_prompt

    # --------------------------
    # USER prompt construction
    # --------------------------
    def _format_conversation_history(
        self,
        conversation_history: Optional[List[Dict[str, str]]],
    ) -> str:
        """
        conversation_history: list of {"speaker": "therapist"|"client", "text": "..."}
        This should already be trimmed in the controller (e.g., last 4–6 turns).
        """
        if not conversation_history:
            return "No prior messages in this conversation for this period.\n"

        lines: List[str] = []
        for turn in conversation_history:
            speaker = turn.get("speaker", "").strip().lower()
            text = turn.get("text", "").strip()
            if not text:
                continue
            if speaker == "therapist":
                prefix = "Therapist"
            elif speaker == "client":
                prefix = self.client_label
            else:
                prefix = speaker or "Unknown"
            lines.append(f"{prefix}: {text}")
        return "\n".join(lines) + "\n"

    def _build_user_prompt_for_turn(
        self,
        diary_paragraph: str,
        period_events: List[Dict[str, Any]],
        therapist_utterance: str,
        conversation_history: Optional[List[Dict[str, str]]] = None,
    ) -> str:
        """
        Build USER prompt with:
          - current diary paragraph
          - JSON facts for period
          - recent conversation history
          - latest therapist utterance
        """
        diary_paragraph = diary_paragraph.strip()

        events_json = json.dumps(
            period_events,
            ensure_ascii=False,
            indent=2
        )

        history_block = self._format_conversation_history(conversation_history)

        user_prompt = f"""### CURRENT CONTEXT (THIS PERIOD'S EVENTS)
Read this diary-like internal monologue to understand how you feel right now:
"{diary_paragraph}"

### FACT CHECK (STRUCTURED EVENTS FOR THIS PERIOD)
The following JSON list contains the ground-truth events for this period:
{events_json}

Use these events as the factual anchor. Do NOT contradict them. You may add small, realistic sensory details and thoughts that are consistent with these facts, but do not invent new major events.

### RECENT CONVERSATION (LAST TURNS IN THIS SESSION)
Below is the recent dialogue in this session:
{history_block}
---
Now continue the conversation from the following therapist message.

Therapist: "{therapist_utterance}"

Now respond as yourself in 2–5 sentences.
Do not explain the JSON or describe this prompt; just answer the therapist naturally based on who you are and what has been happening.
"""
        
        print(user_prompt)
        return user_prompt

    # --------------------------
    # Low-level: reply with given diary + events + history
    # --------------------------
    def generate_reply(
        self,
        diary_paragraph: str,
        period_events: List[Dict[str, Any]],
        therapist_utterance: str,
        conversation_history: Optional[List[Dict[str, str]]] = None,
    ) -> str:
        """
        Generate ONE client reply to the therapist, given:
          - diary_paragraph: narrativized 1-paragraph diary for this period
          - period_events: JSON events for this same period (facts)
          - therapist_utterance: the latest therapist message
          - conversation_history: recent turns [{"speaker": "therapist"/"client", "text": "..."}]
        """
        system_prompt = self._build_system_prompt()
        user_prompt = self._build_user_prompt_for_turn(
            diary_paragraph=diary_paragraph,
            period_events=period_events,
            therapist_utterance=therapist_utterance,
            conversation_history=conversation_history,
        )

        reply = call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            model=self.model,
        )
        return reply.strip()

    # --------------------------
    # Map session index → storyline keys
    # --------------------------
    @staticmethod
    def _period_keys_for_session_start(session_index: int) -> Dict[str, Optional[str]]:
        """
        Map session index k to:
          - current_key: the storyline period used as between-session context
          - previous_key: the storyline period whose diary feeds continuity (Rolling Window = 1)

        Session 1:
          - current_key  = "before_session_1"
          - previous_key = None

        Session 2:
          - current_key  = "between_sessions_1_2"
          - previous_key = "before_session_1"

        Session k>=3:
          - current_key  = f"between_sessions_{k-1}_{k}"
          - previous_key = f"between_sessions_{k-2}_{k-1}"
        """
        if session_index <= 1:
            return {"current_key": "before_session_1", "previous_key": None}
        elif session_index == 2:
            return {
                "current_key": "between_sessions_1_2",
                "previous_key": "before_session_1",
            }
        else:
            current_key = f"between_sessions_{session_index-1}_{session_index}"
            previous_key = f"between_sessions_{session_index-2}_{session_index-1}"
            return {"current_key": current_key, "previous_key": previous_key}

    def _get_or_narrativize_diary_for_session_start(
        self,
        session_index: int,
        storyline: Dict[str, Any],
    ):
        """
        For a given session_index and storyline, make sure the appropriate diary paragraph
        is generated from the UPDATED storyline JSON, using Rolling Window = 1.

        Returns:
          diary_paragraph, period_events, period_key
        """
        keys = self._period_keys_for_session_start(session_index)
        current_key = keys["current_key"]
        previous_key = keys["previous_key"]

        if current_key not in storyline:
            raise KeyError(f"Storyline is missing key '{current_key}' for session {session_index}.")

        period_data = storyline[current_key]
        period_events: List[Dict[str, Any]] = period_data.get("events", [])

        # Rolling Window = 1: previous diary paragraph if available
        previous_paragraph: Optional[str] = None
        if previous_key is not None:
            previous_paragraph = self.diary_store.get(previous_key)

        # Narrativize ON DEMAND and cache
        if current_key not in self.diary_store:
            diary_paragraph = narrativize_period(
                events=period_events,
                previous_paragraph=previous_paragraph,
                model=self.model,
            )
            self.diary_store[current_key] = diary_paragraph
        else:
            diary_paragraph = self.diary_store[current_key]

        return diary_paragraph, period_events, current_key

    # --------------------------
    # High-level: first client turn of a session
    # --------------------------
    def generate_reply_for_session_start(
        self,
        session_index: int,
        storyline: Dict[str, Any],
        therapist_utterance: str,
        conversation_history: Optional[List[Dict[str, str]]] = None,
    ) -> str:
        """
        High-level convenience:
          - Determine which storyline period applies to this session start.
          - Narrativize that period (from UPDATED JSON) if not already cached.
          - Use that diary + events + recent conversation history to generate one client reply.

        For the very first turn of a new session, conversation_history is usually empty.
        """
        diary_paragraph, period_events, _ = self._get_or_narrativize_diary_for_session_start(
            session_index=session_index,
            storyline=storyline,
        )

        return self.generate_reply(
            diary_paragraph=diary_paragraph,
            period_events=period_events,
            therapist_utterance=therapist_utterance,
            conversation_history=conversation_history,
        )

    # --------------------------
    # Long-term summary update
    # --------------------------
    def update_long_term_summary(self, new_summary: str) -> None:
        """
        Overwrite or update the long-term therapy summary (Section B).
        Call this after each session with your Session Summary agent's output.
        """
        self.long_term_summary = new_summary.strip()
